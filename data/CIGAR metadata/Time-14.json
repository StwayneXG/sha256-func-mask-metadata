{
    "bug_id": 14,
    "bug_type": "SF",
    "buggy_lines": "",
    "code": "    public int[] add(ReadablePartial partial, int fieldIndex, int[] values, int valueToAdd) {\n        // overridden as superclass algorithm can't handle\n        // 2004-02-29 + 48 months -> 2008-02-29 type dates\n        if (valueToAdd == 0) {\n            return values;\n        }\n            // month is largest field and being added to, such as month-day\n        if (DateTimeUtils.isContiguous(partial)) {\n            long instant = 0L;\n            for (int i = 0, isize = partial.size(); i < isize; i++) {\n                instant = partial.getFieldType(i).getField(iChronology).set(instant, values[i]);\n            }\n            instant = add(instant, valueToAdd);\n            return iChronology.get(partial, instant);\n        } else {\n            return super.add(partial, fieldIndex, values, valueToAdd);\n        }\n    }",
    "fixed_code": "    public int[] add(ReadablePartial partial, int fieldIndex, int[] values, int valueToAdd) {\n        // overridden as superclass algorithm can't handle\n        // 2004-02-29 + 48 months -> 2008-02-29 type dates\n        if (valueToAdd == 0) {\n            return values;\n        }\n        if (partial.size() > 0 && partial.getFieldType(0).equals(DateTimeFieldType.monthOfYear()) && fieldIndex == 0) {\n            // month is largest field and being added to, such as month-day\n            int curMonth0 = partial.getValue(0) - 1;\n            int newMonth = ((curMonth0 + (valueToAdd % 12) + 12) % 12) + 1;\n            return set(partial, 0, values, newMonth);\n        }\n        if (DateTimeUtils.isContiguous(partial)) {\n            long instant = 0L;\n            for (int i = 0, isize = partial.size(); i < isize; i++) {\n                instant = partial.getFieldType(i).getField(iChronology).set(instant, values[i]);\n            }\n            instant = add(instant, valueToAdd);\n            return iChronology.get(partial, instant);\n        } else {\n            return super.add(partial, fieldIndex, values, valueToAdd);\n        }\n    }",
    "fixed_lines": "        if (partial.size() > 0 && partial.getFieldType(0).equals(DateTimeFieldType.monthOfYear()) && fieldIndex == 0) {\n            int curMonth0 = partial.getValue(0) - 1;\n            int newMonth = ((curMonth0 + (valueToAdd % 12) + 12) % 12) + 1;\n            return set(partial, 0, values, newMonth);\n        }",
    "masked_code": "    public int[] add(ReadablePartial partial, int fieldIndex, int[] values, int valueToAdd) {\n        // overridden as superclass algorithm can't handle\n        // 2004-02-29 + 48 months -> 2008-02-29 type dates\n        if (valueToAdd == 0) {\n            return values;\n        }\n            // month is largest field and being added to, such as month-day\n>>> [ INFILL ] <<<\n        if (DateTimeUtils.isContiguous(partial)) {\n            long instant = 0L;\n            for (int i = 0, isize = partial.size(); i < isize; i++) {\n                instant = partial.getFieldType(i).getField(iChronology).set(instant, values[i]);\n            }\n            instant = add(instant, valueToAdd);\n            return iChronology.get(partial, instant);\n        } else {\n            return super.add(partial, fieldIndex, values, valueToAdd);\n        }\n    }",
    "project": "Time",
    "test_error_message": "org.joda.time.IllegalFieldValueException: Value 29 for dayOfMonth must be in the range [1,28]",
    "test_framework": "defects4j",
    "test_line": "        MonthDay result = test.plusMonths(-1);",
    "test_name": "testPlusMonths_int_negativeFromLeap",
    "test_suite": "org.joda.time.TestMonthDay_Basics",
    "time_buggy": "2012-04-30 12:36:02 +0100",
    "time_fixed": "2012-05-23 12:45:41 +0100"
}