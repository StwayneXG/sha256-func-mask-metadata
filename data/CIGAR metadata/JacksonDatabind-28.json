{
    "bug_id": 28,
    "bug_type": "SF",
    "buggy_lines": "            if (p.getCurrentToken() == JsonToken.START_OBJECT) {\n                p.nextToken();\n            if (p.getCurrentToken() == JsonToken.FIELD_NAME) {\n                return deserializeObject(p, ctxt, ctxt.getNodeFactory());",
    "code": "        public ObjectNode deserialize(JsonParser p, DeserializationContext ctxt) throws IOException\n        {\n            if (p.getCurrentToken() == JsonToken.START_OBJECT) {\n                p.nextToken();\n                return deserializeObject(p, ctxt, ctxt.getNodeFactory());\n            }\n            // 23-Sep-2015, tatu: Ugh. We may also be given END_OBJECT (similar to FIELD_NAME),\n            //    if caller has advanced to the first token of Object, but for empty Object\n            if (p.getCurrentToken() == JsonToken.FIELD_NAME) {\n                return deserializeObject(p, ctxt, ctxt.getNodeFactory());\n            }\n            throw ctxt.mappingException(ObjectNode.class);\n         }\n    }\n        \n    final static class ArrayDeserializer\n        extends BaseNodeDeserializer<ArrayNode>\n    {\n        private static final long serialVersionUID = 1L;\n\n        protected final static ArrayDeserializer _instance = new ArrayDeserializer();\n\n        protected ArrayDeserializer() { super(ArrayNode.class); }\n\n        public static ArrayDeserializer getInstance() { return _instance; }\n        \n        @Override\n        public ArrayNode deserialize(JsonParser p, DeserializationContext ctxt) throws IOException\n        {\n            if (p.isExpectedStartArrayToken()) {\n                return deserializeArray(p, ctxt, ctxt.getNodeFactory());\n            }\n            throw ctxt.mappingException(ArrayNode.class);\n        }",
    "fixed_code": "        public ObjectNode deserialize(JsonParser p, DeserializationContext ctxt) throws IOException\n        {\n            if (p.isExpectedStartObjectToken() || p.hasToken(JsonToken.FIELD_NAME)) {\n                return deserializeObject(p, ctxt, ctxt.getNodeFactory());\n            }\n            // 23-Sep-2015, tatu: Ugh. We may also be given END_OBJECT (similar to FIELD_NAME),\n            //    if caller has advanced to the first token of Object, but for empty Object\n            if (p.hasToken(JsonToken.END_OBJECT)) {\n                return ctxt.getNodeFactory().objectNode();\n            }\n            throw ctxt.mappingException(ObjectNode.class);\n         }\n    }\n        \n    final static class ArrayDeserializer\n        extends BaseNodeDeserializer<ArrayNode>\n    {\n        private static final long serialVersionUID = 1L;\n\n        protected final static ArrayDeserializer _instance = new ArrayDeserializer();\n\n        protected ArrayDeserializer() { super(ArrayNode.class); }\n\n        public static ArrayDeserializer getInstance() { return _instance; }\n        \n        @Override\n        public ArrayNode deserialize(JsonParser p, DeserializationContext ctxt) throws IOException\n        {\n            if (p.isExpectedStartArrayToken()) {\n                return deserializeArray(p, ctxt, ctxt.getNodeFactory());\n            }\n            throw ctxt.mappingException(ArrayNode.class);\n        }",
    "fixed_lines": "            if (p.isExpectedStartObjectToken() || p.hasToken(JsonToken.FIELD_NAME)) {\n            if (p.hasToken(JsonToken.END_OBJECT)) {\n                return ctxt.getNodeFactory().objectNode();",
    "masked_code": "        public ObjectNode deserialize(JsonParser p, DeserializationContext ctxt) throws IOException\n        {\n                return deserializeObject(p, ctxt, ctxt.getNodeFactory());\n            }\n            // 23-Sep-2015, tatu: Ugh. We may also be given END_OBJECT (similar to FIELD_NAME),\n            //    if caller has advanced to the first token of Object, but for empty Object\n>>> [ INFILL ] <<<\n            }\n            throw ctxt.mappingException(ObjectNode.class);\n         }\n    }\n        \n    final static class ArrayDeserializer\n        extends BaseNodeDeserializer<ArrayNode>\n    {\n        private static final long serialVersionUID = 1L;\n\n        protected final static ArrayDeserializer _instance = new ArrayDeserializer();\n\n        protected ArrayDeserializer() { super(ArrayNode.class); }\n\n        public static ArrayDeserializer getInstance() { return _instance; }\n        \n        @Override\n        public ArrayNode deserialize(JsonParser p, DeserializationContext ctxt) throws IOException\n        {\n            if (p.isExpectedStartArrayToken()) {\n                return deserializeArray(p, ctxt, ctxt.getNodeFactory());\n            }\n            throw ctxt.mappingException(ArrayNode.class);\n        }",
    "project": "JacksonDatabind",
    "test_error_message": "com.fasterxml.jackson.databind.JsonMappingException: Can not deserialize instance of com.fasterxml.jackson.databind.node.ObjectNode out of END_OBJECT token",
    "test_framework": "defects4j",
    "test_line": "        MyValue de2 = MAPPER.readValue(json, MyValue.class);  // but this throws exception",
    "test_name": "testIssue941",
    "test_suite": "com.fasterxml.jackson.databind.node.TestObjectNode",
    "time_buggy": "2015-09-23 15:36:00 -0700",
    "time_fixed": "2015-09-23 16:04:09 -0700"
}