{
    "bug_id": 51,
    "bug_type": "SL SH SF",
    "buggy_lines": "        return (c >= 'A' && c <= 'Z') || (c >= 'a' && c <= 'z');",
    "code": "final class CharacterReader {\n        }\n\n        return pos > start ? cacheString(start, pos-start) : \"\";\n    }\n\n    String consumeData() {\n        // &, <, null\n        final int start = pos;\n        final int remaining = length;\n        final char[] val = input;\n\n        while (pos < remaining) {\n            final char c = val[pos];\n            if (c == '&'|| c ==  '<' || c ==  TokeniserState.nullChar)\n                break;\n            pos++;\n        }\n\n        return pos > start ? cacheString(start, pos-start) : \"\";\n    }\n\n    String consumeTagName() {\n        // '\\t', '\\n', '\\r', '\\f', ' ', '/', '>', nullChar\n        final int start = pos;\n        final int remaining = length;\n        final char[] val = input;\n\n        while (pos < remaining) {\n            final char c = val[pos];\n            if (c == '\\t'|| c ==  '\\n'|| c ==  '\\r'|| c ==  '\\f'|| c ==  ' '|| c ==  '/'|| c ==  '>'|| c ==  TokeniserState.nullChar)\n                break;\n            pos++;\n        }\n\n        return pos > start ? cacheString(start, pos-start) : \"\";\n    }\n\n    String consumeToEnd() {\n        String data = cacheString(pos, length-pos);\n        pos = length;\n        return data;\n    }\n\n    String consumeLetterSequence() {\n        int start = pos;\n        while (pos < length) {\n            char c = input[pos];\n            if ((c >= 'A' && c <= 'Z') || (c >= 'a' && c <= 'z'))\n                pos++;\n            else\n                break;\n        }\n\n        return cacheString(start, pos - start);\n    }\n\n    String consumeLetterThenDigitSequence() {\n        int start = pos;\n        while (pos < length) {\n            char c = input[pos];\n            if ((c >= 'A' && c <= 'Z') || (c >= 'a' && c <= 'z'))\n                pos++;\n            else\n                break;\n        }\n        while (!isEmpty()) {\n            char c = input[pos];\n            if (c >= '0' && c <= '9')\n                pos++;\n            else\n                break;\n        }\n\n        return cacheString(start, pos - start);\n    }\n\n    String consumeHexSequence() {\n        int start = pos;\n        while (pos < length) {\n            char c = input[pos];\n            if ((c >= '0' && c <= '9') || (c >= 'A' && c <= 'F') || (c >= 'a' && c <= 'f'))\n                pos++;\n            else\n                break;\n        }\n        return cacheString(start, pos - start);\n    }\n\n    String consumeDigitSequence() {\n        int start = pos;\n        while (pos < length) {\n            char c = input[pos];\n            if (c >= '0' && c <= '9')\n                pos++;\n            else\n                break;\n        }\n        return cacheString(start, pos - start);\n    }\n\n    boolean matches(char c) {\n        return !isEmpty() && input[pos] == c;\n\n    }\n\n    boolean matches(String seq) {\n        int scanLength = seq.length();\n        if (scanLength > length - pos)\n            return false;\n\n        for (int offset = 0; offset < scanLength; offset++)\n            if (seq.charAt(offset) != input[pos+offset])\n                return false;\n        return true;\n    }\n\n    boolean matchesIgnoreCase(String seq) {\n        int scanLength = seq.length();\n        if (scanLength > length - pos)\n            return false;\n\n        for (int offset = 0; offset < scanLength; offset++) {\n            char upScan = Character.toUpperCase(seq.charAt(offset));\n            char upTarget = Character.toUpperCase(input[pos + offset]);\n            if (upScan != upTarget)\n                return false;\n        }\n        return true;\n    }\n\n    boolean matchesAny(char... seq) {\n        if (isEmpty())\n            return false;\n\n        char c = input[pos];\n        for (char seek : seq) {\n            if (seek == c)\n                return true;\n        }\n        return false;\n    }\n\n    boolean matchesAnySorted(char[] seq) {\n        return !isEmpty() && Arrays.binarySearch(seq, input[pos]) >= 0;\n    }\n\n    boolean matchesLetter() {\n        if (isEmpty())\n            return false;\n        char c = input[pos];\n        return (c >= 'A' && c <= 'Z') || (c >= 'a' && c <= 'z');\n    }\n\n    boolean matchesDigit() {\n        if (isEmpty())\n            return false;\n        char c = input[pos];\n        return (c >= '0' && c <= '9');\n    }\n\n    boolean matchConsume(String seq) {\n        if (matches(seq)) {\n            pos += seq.length();\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    boolean matchConsumeIgnoreCase(String seq) {\n        if (matchesIgnoreCase(seq)) {\n            pos += seq.length();\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    boolean containsIgnoreCase(String seq) {\n        // used to check presence of </title>, </style>. only finds consistent case.\n        String loScan = seq.toLowerCase(Locale.ENGLISH);\n        String hiScan = seq.toUpperCase(Locale.ENGLISH);\n        return (nextIndexOf(loScan) > -1) || (nextIndexOf(hiScan) > -1);\n    }\n\n    @Override\n    public String toString() {\n        return new String(input, pos, length - pos);\n    }\n\n    /**\n     * Caches short strings, as a flywheel pattern, to reduce GC load. Just for this doc, to prevent leaks.\n     * <p />\n     * Simplistic, and on hash collisions just falls back to creating a new string, vs a full HashMap with Entry list.\n     * That saves both having to create objects as hash keys, and running through the entry list, at the expense of\n     * some more duplicates.\n     */\n    private String cacheString(final int start, final int count) {\n        final char[] val = input;\n        final String[] cache = stringCache;\n\n        // limit (no cache):\n        if (count > maxCacheLen)\n            return new String(val, start, count);\n\n        // calculate hash:\n        int hash = 0;\n        int offset = start;\n        for (int i = 0; i < count; i++) {\n            hash = 31 * hash + val[offset++];\n        }\n\n        // get from cache\n        final int index = hash & cache.length - 1;\n        String cached = cache[index];\n\n        if (cached == null) { // miss, add\n            cached = new String(val, start, count);\n            cache[index] = cached;\n        } else { // hashcode hit, check equality\n            if (rangeEquals(start, count, cached)) { // hit\n                return cached;\n            } else { // hashcode conflict\n                cached = new String(val, start, count);\n                cache[index] = cached; // update the cache, as recently used strings are more likely to show up again\n            }\n        }\n        return cached;\n    }\n\n    /**\n     * Check if the value of the provided range equals the string.\n     */\n    boolean rangeEquals(final int start, int count, final String cached) {\n        if (count == cached.length()) {\n            char one[] = input;\n            int i = start;\n            int j = 0;\n            while (count-- != 0) {\n                if (one[i++] != cached.charAt(j++))\n                    return false;\n            }\n            return true;\n        }\n        return false;\n    }\n}",
    "fixed_code": "final class CharacterReader {\n        }\n\n        return pos > start ? cacheString(start, pos-start) : \"\";\n    }\n\n    String consumeData() {\n        // &, <, null\n        final int start = pos;\n        final int remaining = length;\n        final char[] val = input;\n\n        while (pos < remaining) {\n            final char c = val[pos];\n            if (c == '&'|| c ==  '<' || c ==  TokeniserState.nullChar)\n                break;\n            pos++;\n        }\n\n        return pos > start ? cacheString(start, pos-start) : \"\";\n    }\n\n    String consumeTagName() {\n        // '\\t', '\\n', '\\r', '\\f', ' ', '/', '>', nullChar\n        final int start = pos;\n        final int remaining = length;\n        final char[] val = input;\n\n        while (pos < remaining) {\n            final char c = val[pos];\n            if (c == '\\t'|| c ==  '\\n'|| c ==  '\\r'|| c ==  '\\f'|| c ==  ' '|| c ==  '/'|| c ==  '>'|| c ==  TokeniserState.nullChar)\n                break;\n            pos++;\n        }\n\n        return pos > start ? cacheString(start, pos-start) : \"\";\n    }\n\n    String consumeToEnd() {\n        String data = cacheString(pos, length-pos);\n        pos = length;\n        return data;\n    }\n\n    String consumeLetterSequence() {\n        int start = pos;\n        while (pos < length) {\n            char c = input[pos];\n            if ((c >= 'A' && c <= 'Z') || (c >= 'a' && c <= 'z'))\n                pos++;\n            else\n                break;\n        }\n\n        return cacheString(start, pos - start);\n    }\n\n    String consumeLetterThenDigitSequence() {\n        int start = pos;\n        while (pos < length) {\n            char c = input[pos];\n            if ((c >= 'A' && c <= 'Z') || (c >= 'a' && c <= 'z'))\n                pos++;\n            else\n                break;\n        }\n        while (!isEmpty()) {\n            char c = input[pos];\n            if (c >= '0' && c <= '9')\n                pos++;\n            else\n                break;\n        }\n\n        return cacheString(start, pos - start);\n    }\n\n    String consumeHexSequence() {\n        int start = pos;\n        while (pos < length) {\n            char c = input[pos];\n            if ((c >= '0' && c <= '9') || (c >= 'A' && c <= 'F') || (c >= 'a' && c <= 'f'))\n                pos++;\n            else\n                break;\n        }\n        return cacheString(start, pos - start);\n    }\n\n    String consumeDigitSequence() {\n        int start = pos;\n        while (pos < length) {\n            char c = input[pos];\n            if (c >= '0' && c <= '9')\n                pos++;\n            else\n                break;\n        }\n        return cacheString(start, pos - start);\n    }\n\n    boolean matches(char c) {\n        return !isEmpty() && input[pos] == c;\n\n    }\n\n    boolean matches(String seq) {\n        int scanLength = seq.length();\n        if (scanLength > length - pos)\n            return false;\n\n        for (int offset = 0; offset < scanLength; offset++)\n            if (seq.charAt(offset) != input[pos+offset])\n                return false;\n        return true;\n    }\n\n    boolean matchesIgnoreCase(String seq) {\n        int scanLength = seq.length();\n        if (scanLength > length - pos)\n            return false;\n\n        for (int offset = 0; offset < scanLength; offset++) {\n            char upScan = Character.toUpperCase(seq.charAt(offset));\n            char upTarget = Character.toUpperCase(input[pos + offset]);\n            if (upScan != upTarget)\n                return false;\n        }\n        return true;\n    }\n\n    boolean matchesAny(char... seq) {\n        if (isEmpty())\n            return false;\n\n        char c = input[pos];\n        for (char seek : seq) {\n            if (seek == c)\n                return true;\n        }\n        return false;\n    }\n\n    boolean matchesAnySorted(char[] seq) {\n        return !isEmpty() && Arrays.binarySearch(seq, input[pos]) >= 0;\n    }\n\n    boolean matchesLetter() {\n        if (isEmpty())\n            return false;\n        char c = input[pos];\n        return (c >= 'A' && c <= 'Z') || (c >= 'a' && c <= 'z') || Character.isLetter(c);\n    }\n\n    boolean matchesDigit() {\n        if (isEmpty())\n            return false;\n        char c = input[pos];\n        return (c >= '0' && c <= '9');\n    }\n\n    boolean matchConsume(String seq) {\n        if (matches(seq)) {\n            pos += seq.length();\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    boolean matchConsumeIgnoreCase(String seq) {\n        if (matchesIgnoreCase(seq)) {\n            pos += seq.length();\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    boolean containsIgnoreCase(String seq) {\n        // used to check presence of </title>, </style>. only finds consistent case.\n        String loScan = seq.toLowerCase(Locale.ENGLISH);\n        String hiScan = seq.toUpperCase(Locale.ENGLISH);\n        return (nextIndexOf(loScan) > -1) || (nextIndexOf(hiScan) > -1);\n    }\n\n    @Override\n    public String toString() {\n        return new String(input, pos, length - pos);\n    }\n\n    /**\n     * Caches short strings, as a flywheel pattern, to reduce GC load. Just for this doc, to prevent leaks.\n     * <p />\n     * Simplistic, and on hash collisions just falls back to creating a new string, vs a full HashMap with Entry list.\n     * That saves both having to create objects as hash keys, and running through the entry list, at the expense of\n     * some more duplicates.\n     */\n    private String cacheString(final int start, final int count) {\n        final char[] val = input;\n        final String[] cache = stringCache;\n\n        // limit (no cache):\n        if (count > maxCacheLen)\n            return new String(val, start, count);\n\n        // calculate hash:\n        int hash = 0;\n        int offset = start;\n        for (int i = 0; i < count; i++) {\n            hash = 31 * hash + val[offset++];\n        }\n\n        // get from cache\n        final int index = hash & cache.length - 1;\n        String cached = cache[index];\n\n        if (cached == null) { // miss, add\n            cached = new String(val, start, count);\n            cache[index] = cached;\n        } else { // hashcode hit, check equality\n            if (rangeEquals(start, count, cached)) { // hit\n                return cached;\n            } else { // hashcode conflict\n                cached = new String(val, start, count);\n                cache[index] = cached; // update the cache, as recently used strings are more likely to show up again\n            }\n        }\n        return cached;\n    }\n\n    /**\n     * Check if the value of the provided range equals the string.\n     */\n    boolean rangeEquals(final int start, int count, final String cached) {\n        if (count == cached.length()) {\n            char one[] = input;\n            int i = start;\n            int j = 0;\n            while (count-- != 0) {\n                if (one[i++] != cached.charAt(j++))\n                    return false;\n            }\n            return true;\n        }\n        return false;\n    }\n}",
    "fixed_lines": "        return (c >= 'A' && c <= 'Z') || (c >= 'a' && c <= 'z') || Character.isLetter(c);",
    "masked_code": "final class CharacterReader {\n        }\n\n        return pos > start ? cacheString(start, pos-start) : \"\";\n    }\n\n    String consumeData() {\n        // &, <, null\n        final int start = pos;\n        final int remaining = length;\n        final char[] val = input;\n\n        while (pos < remaining) {\n            final char c = val[pos];\n            if (c == '&'|| c ==  '<' || c ==  TokeniserState.nullChar)\n                break;\n            pos++;\n        }\n\n        return pos > start ? cacheString(start, pos-start) : \"\";\n    }\n\n    String consumeTagName() {\n        // '\\t', '\\n', '\\r', '\\f', ' ', '/', '>', nullChar\n        final int start = pos;\n        final int remaining = length;\n        final char[] val = input;\n\n        while (pos < remaining) {\n            final char c = val[pos];\n            if (c == '\\t'|| c ==  '\\n'|| c ==  '\\r'|| c ==  '\\f'|| c ==  ' '|| c ==  '/'|| c ==  '>'|| c ==  TokeniserState.nullChar)\n                break;\n            pos++;\n        }\n\n        return pos > start ? cacheString(start, pos-start) : \"\";\n    }\n\n    String consumeToEnd() {\n        String data = cacheString(pos, length-pos);\n        pos = length;\n        return data;\n    }\n\n    String consumeLetterSequence() {\n        int start = pos;\n        while (pos < length) {\n            char c = input[pos];\n            if ((c >= 'A' && c <= 'Z') || (c >= 'a' && c <= 'z'))\n                pos++;\n            else\n                break;\n        }\n\n        return cacheString(start, pos - start);\n    }\n\n    String consumeLetterThenDigitSequence() {\n        int start = pos;\n        while (pos < length) {\n            char c = input[pos];\n            if ((c >= 'A' && c <= 'Z') || (c >= 'a' && c <= 'z'))\n                pos++;\n            else\n                break;\n        }\n        while (!isEmpty()) {\n            char c = input[pos];\n            if (c >= '0' && c <= '9')\n                pos++;\n            else\n                break;\n        }\n\n        return cacheString(start, pos - start);\n    }\n\n    String consumeHexSequence() {\n        int start = pos;\n        while (pos < length) {\n            char c = input[pos];\n            if ((c >= '0' && c <= '9') || (c >= 'A' && c <= 'F') || (c >= 'a' && c <= 'f'))\n                pos++;\n            else\n                break;\n        }\n        return cacheString(start, pos - start);\n    }\n\n    String consumeDigitSequence() {\n        int start = pos;\n        while (pos < length) {\n            char c = input[pos];\n            if (c >= '0' && c <= '9')\n                pos++;\n            else\n                break;\n        }\n        return cacheString(start, pos - start);\n    }\n\n    boolean matches(char c) {\n        return !isEmpty() && input[pos] == c;\n\n    }\n\n    boolean matches(String seq) {\n        int scanLength = seq.length();\n        if (scanLength > length - pos)\n            return false;\n\n        for (int offset = 0; offset < scanLength; offset++)\n            if (seq.charAt(offset) != input[pos+offset])\n                return false;\n        return true;\n    }\n\n    boolean matchesIgnoreCase(String seq) {\n        int scanLength = seq.length();\n        if (scanLength > length - pos)\n            return false;\n\n        for (int offset = 0; offset < scanLength; offset++) {\n            char upScan = Character.toUpperCase(seq.charAt(offset));\n            char upTarget = Character.toUpperCase(input[pos + offset]);\n            if (upScan != upTarget)\n                return false;\n        }\n        return true;\n    }\n\n    boolean matchesAny(char... seq) {\n        if (isEmpty())\n            return false;\n\n        char c = input[pos];\n        for (char seek : seq) {\n            if (seek == c)\n                return true;\n        }\n        return false;\n    }\n\n    boolean matchesAnySorted(char[] seq) {\n        return !isEmpty() && Arrays.binarySearch(seq, input[pos]) >= 0;\n    }\n\n    boolean matchesLetter() {\n        if (isEmpty())\n            return false;\n        char c = input[pos];\n>>> [ INFILL ] <<<\n    }\n\n    boolean matchesDigit() {\n        if (isEmpty())\n            return false;\n        char c = input[pos];\n        return (c >= '0' && c <= '9');\n    }\n\n    boolean matchConsume(String seq) {\n        if (matches(seq)) {\n            pos += seq.length();\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    boolean matchConsumeIgnoreCase(String seq) {\n        if (matchesIgnoreCase(seq)) {\n            pos += seq.length();\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    boolean containsIgnoreCase(String seq) {\n        // used to check presence of </title>, </style>. only finds consistent case.\n        String loScan = seq.toLowerCase(Locale.ENGLISH);\n        String hiScan = seq.toUpperCase(Locale.ENGLISH);\n        return (nextIndexOf(loScan) > -1) || (nextIndexOf(hiScan) > -1);\n    }\n\n    @Override\n    public String toString() {\n        return new String(input, pos, length - pos);\n    }\n\n    /**\n     * Caches short strings, as a flywheel pattern, to reduce GC load. Just for this doc, to prevent leaks.\n     * <p />\n     * Simplistic, and on hash collisions just falls back to creating a new string, vs a full HashMap with Entry list.\n     * That saves both having to create objects as hash keys, and running through the entry list, at the expense of\n     * some more duplicates.\n     */\n    private String cacheString(final int start, final int count) {\n        final char[] val = input;\n        final String[] cache = stringCache;\n\n        // limit (no cache):\n        if (count > maxCacheLen)\n            return new String(val, start, count);\n\n        // calculate hash:\n        int hash = 0;\n        int offset = start;\n        for (int i = 0; i < count; i++) {\n            hash = 31 * hash + val[offset++];\n        }\n\n        // get from cache\n        final int index = hash & cache.length - 1;\n        String cached = cache[index];\n\n        if (cached == null) { // miss, add\n            cached = new String(val, start, count);\n            cache[index] = cached;\n        } else { // hashcode hit, check equality\n            if (rangeEquals(start, count, cached)) { // hit\n                return cached;\n            } else { // hashcode conflict\n                cached = new String(val, start, count);\n                cache[index] = cached; // update the cache, as recently used strings are more likely to show up again\n            }\n        }\n        return cached;\n    }\n\n    /**\n     * Check if the value of the provided range equals the string.\n     */\n    boolean rangeEquals(final int start, int count, final String cached) {\n        if (count == cached.length()) {\n            char one[] = input;\n            int i = start;\n            int j = 0;\n            while (count-- != 0) {\n                if (one[i++] != cached.charAt(j++))\n                    return false;\n            }\n            return true;\n        }\n        return false;\n    }\n}",
    "project": "Jsoup",
    "test_error_message": "junit.framework.AssertionFailedError: expected:<[Yes]> but was:<[]>",
    "test_framework": "defects4j",
    "test_line": "        assertEquals(\"Yes\", els.text());",
    "test_name": "testSupportsNonAsciiTags",
    "test_suite": "org.jsoup.parser.HtmlParserTest",
    "time_buggy": "2016-04-05 16:32:54 -0700",
    "time_fixed": "2016-04-05 17:05:20 -0700"
}